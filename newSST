// SPDX-License-Identifier: MIT

/*
Website : https://securestash.in
Telegram: https://t.me/securestash
Twitter : https://twitter.com/SecureStash
Github  : https://github.com/SecureStash/
*/

pragma solidity ^0.8.20;
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract SecureStash is ERC20, Ownable, ReentrancyGuard {
    uint256 public circulatingSupply;
    uint256 public totalMint;
    uint256 public totalBurn;
    uint256 public totalVested;
    uint256 public otherInitialAllocation;
    uint256 public combinedSaleBalance;
    address public deadWallet;
    uint256 public launchTime;
    uint256 public constant MAX_SUPPLY = 100000000;  // * 10 ** 18; // 100M tokens with 18 decimals
    uint256 public TAX_RATE = 5;                                    // 0.5% tax applied only on DEX trades
    uint256 public constant TOKENS_RELEASE = 60;//1 minute;
    //uint256 public constant TOKENS_RELEASE = 30 days;
    uint256 public constant MONTHS_IN_4_YEARS = 48;
    uint256 public constant INITIAL_RELEASE_PERCENTAGE = 4;
    uint256 public constant VESTING_PERCENTAGE = 96;
    uint256 internal constant volatileControlPercentage = 50;         // 50% of the total supply
    uint256 internal constant exchangeListingPercentage = 10;         // 10% of the total supply
    uint256 internal constant ecosystemDevelopmentPercentage = 5;     // 5% of the total supply
    uint256 internal constant teamPercentage = 4;                     // 4% of the total supply
    uint256 internal constant reservesPercentage = 1;                 // 1% of the total supply
    uint256 public umonthstamp;
    uint256 public ulsw;
    uint256 public umaxp;
    uint256 public udistribute;
    uint256 public ulwds;
    uint256 public uamt;


    address[5] public fundAllocationAddressesArray;                 // Array to store fund allocation addresses
    bool public paused = false;                                     // State variable to track if sales are paused

    enum SaleType { Seed, Private, Public }
    enum AllocationType { VolatileControl, ExchangeListing, EcosystemDevelopment, Team, Reserve }

    // Struct to hold sale details
    struct Sale {
        uint256 tokensAvailable;
        uint256 rate;
        bool isActive;
    }
 
    struct SaleData {
        uint256 initialBalance;
        uint256 vestedTokens;
        uint256 totalVested;
        uint256 totalSale;
        uint256 monthlyRelease;
    }
    
    struct AllocationAddress {
        string allocationType;
        address addr;
    }

    mapping(SaleType => Sale) public sales;                                     
    mapping(SaleType => uint256) public totalTokensSold;
    mapping(address => uint256) public lastWithdrawal;
    mapping(address => bool) public isDex;
    mapping(address => AllocationType) public addressToAllocationType;
    mapping(address => bool) public isWhitelisted;
    mapping(uint => mapping(address => uint256)) public vestedSaleTokens;
    mapping(uint => mapping(address => uint256)) public totalVestedBalances;
    mapping(uint => mapping(address => SaleData)) public saleData;
    mapping(AllocationType => uint256) public tokensAllocated;
    mapping(AllocationType => bool) public initialDistributionDone;
    
    event TokensBought(address indexed buyer, uint256 amount);
    event TokensMinted(address indexed to, uint256 amount);
    event TokensBurned(address indexed from, uint256 amount, string reason);
    event TokensWithdrawn(address indexed from, uint256 amount);
    event TokenAllocated(address indexed sender, address indexed recipient, uint256 amount, AllocationType allocationType);
    event TokenVested(address indexed beneficiary, uint256 amount, AllocationType allocationType, uint256 timestamp);
    event SaleRateUpdated(SaleType saleType, uint256 newRate);
    event SaleActivated(SaleType saleType, uint256 timestamp);
    event SalePaused(SaleType saleType);
    event SaleResumed(SaleType saleType, uint256 newRate);

    constructor() ERC20("Secure Stash", "SST") {
        _mint(address(this), MAX_SUPPLY);
        totalMint = totalSupply();
        launchTime = block.timestamp;
        lastWithdrawal[address(this)] = launchTime;
        deadWallet = 0x000000000000000000000000000000000000dEaD;

        // Initial allocations for each category
        sales[SaleType.Seed].tokensAvailable = totalSupply() * 25 / 1000;               // 2.5% of total supply;
        sales[SaleType.Private].tokensAvailable = totalSupply() * 175 / 1000;           // 17.5% of total supply;
        sales[SaleType.Public].tokensAvailable = totalSupply() * 10 / 100;              // 10% of total supply;
        
        // Setting the buy rates for each sale type
        sales[SaleType.Seed].rate = 8400;
        sales[SaleType.Private].rate = 400;
        sales[SaleType.Public].rate = 275;

        tokensAllocated[AllocationType.VolatileControl] = (totalSupply() * volatileControlPercentage / 100 * INITIAL_RELEASE_PERCENTAGE) / 100;
        tokensAllocated[AllocationType.ExchangeListing] = (totalSupply() * exchangeListingPercentage / 100 * INITIAL_RELEASE_PERCENTAGE) / 100;
        tokensAllocated[AllocationType.EcosystemDevelopment] = (totalSupply() * ecosystemDevelopmentPercentage / 100 * INITIAL_RELEASE_PERCENTAGE) / 100;
        tokensAllocated[AllocationType.Team] = (totalSupply() * teamPercentage / 100 * INITIAL_RELEASE_PERCENTAGE) / 100;
        tokensAllocated[AllocationType.Reserve] = (totalSupply() * reservesPercentage / 100 * INITIAL_RELEASE_PERCENTAGE) / 100;

        // Total initial allocation tokens excluding sale tokens - 70M SST
        otherInitialAllocation = tokensAllocated[AllocationType.VolatileControl] + tokensAllocated[AllocationType.ExchangeListing] + tokensAllocated[AllocationType.EcosystemDevelopment] + tokensAllocated[AllocationType.Team] + tokensAllocated[AllocationType.Reserve];

        // 96% of the 70M (excluding 30M allocated for sales) are vested. Tokens sold are vested through buy function.
        
        totalVested = (totalSupply() * volatileControlPercentage / 100 * VESTING_PERCENTAGE) / 100
                    + (totalSupply() * exchangeListingPercentage / 100 * VESTING_PERCENTAGE) / 100
                    + (totalSupply() * ecosystemDevelopmentPercentage / 100 * VESTING_PERCENTAGE) / 100
                    + (totalSupply() * teamPercentage / 100 * VESTING_PERCENTAGE) / 100
                    + (totalSupply() * reservesPercentage / 100 * VESTING_PERCENTAGE) / 100;

        combinedSaleBalance = totalSupply() - (totalVested + otherInitialAllocation);
        circulatingSupply = totalMint - totalBurn - totalVested;
    }

    // Modifier to check if the sale is active
    modifier onlyWhenSaleActive(SaleType saleType) {
        require(sales[saleType].isActive, "Sale is not active");
        _;
    }

    // Modifier to check if sales are paused
    modifier whenNotPaused() {
        require(!paused, "Sales are paused");
        _;
    }

    //Modifier to check if users are eligible to participate in seed or private sale
    modifier onlyWhitelisted() {
        require(isWhitelisted[msg.sender], "Address not whitelisted");
        _;
    }

    // Function to activate a sale
    function activateSale(SaleType saleType, uint256 rate, uint256 tokensForSale) public onlyOwner {
        require(tokensForSale > 0, "Tokens for sale should be greater than 0");
        require(tokensForSale <= combinedSaleBalance, "Cannot allocate more tokens than the combined sale balance");
        require(!sales[saleType].isActive, "Sale is already active");

        Sale storage sale = sales[saleType];
        sale.rate = rate;
        sale.tokensAvailable = tokensForSale;  // Update the tokens available for the sale
        sale.isActive = true;
        combinedSaleBalance -= tokensForSale;  // Deduct the allocated tokens from the combined sale balance

        emit SaleActivated(saleType, block.timestamp);
    }

    // Function to pause a sale
    function pauseSale(SaleType saleType) external onlyOwner {
        require(sales[saleType].isActive, "Sale is not active");
        sales[saleType].isActive = false;
        emit SalePaused(saleType);
    }

    // Function to resume a sale with an option to set a new rate
    function resumeSale(SaleType saleType, uint256 newRate) external onlyOwner {
        require(!sales[saleType].isActive, "Sale is already active");
        sales[saleType].rate = newRate;  // Update the sale rate with the new rate
        sales[saleType].isActive = true;
        emit SaleResumed(saleType, newRate);
    }

    //Function to whitelist users to participate in seed or private sale
    function addToWhitelist(address _address) external onlyOwner {
        isWhitelisted[_address] = true;
    }

    function removeFromWhitelist(address _address) external onlyOwner {
        isWhitelisted[_address] = false;
    }
    
    function setTaxRates(uint256 _taxRate) external onlyOwner {
        require(_taxRate <= 5, "Tax cannot exceed 0.5%");
        TAX_RATE = _taxRate;
    }

    // Function to add a DEX address
    function addDex(address _dex) public onlyOwner {
        isDex[_dex] = true;
    }
    
    // Function to remove a DEX address
    function removeDex(address _dex) public onlyOwner {
        isDex[_dex] = false;
    }

    function _updateCirculatingSupply() private {
        circulatingSupply = totalMint - totalBurn - totalVested;
    }

    function transfer(address recipient, uint256 amount) public override nonReentrant returns (bool) {
        require(balanceOf(msg.sender) >= amount, "Insufficient balance");
        uint256 tax = 0;
        if (isDex[recipient] || isDex[msg.sender]) {
            tax = (amount * TAX_RATE) / 1000;                // Calculate tax
        }
        uint256 netValue = amount - tax;                    // Calculate net value to be transferred

        // Send tax to dead wallet and reduce total supply
        if (tax > 0) {
            super.transfer(deadWallet, tax);
            _burn(deadWallet, tax);                         // Burn the tokens sent to the dead wallet
            totalBurn = totalBurn + tax;                    // Update total tokens burnt
            emit TokensBurned(msg.sender, tax, "Tax Burn");
            _updateCirculatingSupply();                     //Update Circulating Supply
        }
        return super.transfer(recipient, netValue);         // Call the original transfer function
    }

    function updateFundAllocationAddress(AllocationType allocationType, address newAddress) public onlyOwner {
        require(newAddress != address(0), "Invalid address");
        
        // Check if the address is already assigned to another AllocationType
        for (uint i = 0; i < 5; i++) {
            require(fundAllocationAddressesArray[i] != newAddress, "Address already allocated");
        }

        // If the address is already set for the given allocationType, remove it
        for (uint i = 0; i < 5; i++) {
            if (fundAllocationAddressesArray[i] == newAddress) {
                delete addressToAllocationType[fundAllocationAddressesArray[i]];
                fundAllocationAddressesArray[i] = address(0);
            }
        }

        // Update the address for the given allocationType
        addressToAllocationType[newAddress] = allocationType;
        fundAllocationAddressesArray[uint(allocationType)] = newAddress;

        // If the initial distribution hasn't occurred for this allocationType, do it now
        if (!initialDistributionDone[allocationType]){

            // Transfer the tokens allocated for the AllocationType to the new address only if balance is greater than 0
            uint256 tokensToTransfer = tokensAllocated[allocationType];
            _transfer(address(this), newAddress, tokensToTransfer); // Transfer tokens from the contract to the new address
            
            /*if (tokensToTransfer > 0) {
            _transfer(address(this), newAddress, tokensToTransfer); // Transfer tokens from the contract to the new address
            }           //This condition may not be required because the tokens are transferred only during initial distribution*/

            // Mark the initial distribution as done for this allocationType
            initialDistributionDone[allocationType] = true;
        }
    }

    function mint(uint256 amount) public onlyOwner {
        require((totalSupply() + amount) <= MAX_SUPPLY, "Cannot exceed Maximum supply");
        address ecosystemWallet = fundAllocationAddressesArray[2];              // 2 represents Ecosystem Development
        require(ecosystemWallet != address(0), "Ecosystem wallet not set");
        _mint(ecosystemWallet, amount);
        totalMint += amount;
        _updateCirculatingSupply();
        emit TokensMinted(ecosystemWallet, amount);
    }
    
    function burn(uint256 amount) public {
        _burn(msg.sender, amount);
        totalBurn += amount;
        _updateCirculatingSupply();
        emit TokensBurned(msg.sender, amount, "Manual Burn");
    }

    function _updateUserSale(SaleData storage userSale, uint256 initialAllocation, uint256 vestedTokens, uint256 totalSale, uint256 monthlyRelease) internal {
        userSale.initialBalance += initialAllocation;
        userSale.vestedTokens += vestedTokens;
        userSale.totalSale += totalSale;
        userSale.monthlyRelease += monthlyRelease;
    }

    function buySale(SaleType saleType, uint256 amount) public payable onlyWhenSaleActive(saleType) nonReentrant {
        if (saleType == SaleType.Seed || saleType == SaleType.Private) {
            require(isWhitelisted[msg.sender], "Only whitelisted addresses can participate in this sale");
        }

        Sale storage sale = sales[saleType];                                // Access the sale from the mapping based on SaleType
        amount = msg.value * sales[saleType].rate;
    
        require(amount <= sale.tokensAvailable, "Not enough tokens available for sale");
        
        uint256 initialAllocation = (amount * INITIAL_RELEASE_PERCENTAGE) / 100;                        // Initial sale tokens sent
        uint256 vestedTokens = amount - initialAllocation;             // Sale Tokens sent for vesting
        uint256 totalSale = amount;
        uint256 monthlyRelease = ((totalSale - initialAllocation) / MONTHS_IN_4_YEARS);
        totalVested += vestedTokens;                                        // Update the total tokens vested
        sale.tokensAvailable -= amount;                                     // Update available sale total balances
        totalTokensSold[saleType] += amount;                                // Update the total tokens sold for the sale type

        SaleData storage userSale = saleData[uint(saleType)][msg.sender];
        _updateUserSale(userSale, initialAllocation, vestedTokens, totalSale, monthlyRelease);
        _updateCirculatingSupply();
        _transfer(address(this), msg.sender, initialAllocation);                   // Transfer the initial allocation to the buyer
        emit TokensBought(msg.sender, amount);                              // Emit the TokensBought event
        }

    function withdrawVestedSaleTokens() public nonReentrant {
        uint256 totalAmount = 0;
        

        // Calculate the number of periods since the contract launch time
        uint256 periodsSinceLaunch = (block.timestamp - launchTime) / TOKENS_RELEASE;

        // Iterate over each sale type
        for (uint i = 0; i < 3; i++) {
            SaleType saleType = SaleType(i);
            SaleData storage userSale = saleData[uint(saleType)][msg.sender];
            if (userSale.vestedTokens == 0) continue; // Skip if the user has no vested tokens for the sale type

            // Calculate the number of periods since the last withdrawal
            uint256 periodsSinceLastWithdrawal = (block.timestamp - lastWithdrawal[msg.sender]) / TOKENS_RELEASE;

            // Ensure the user waits for at least one period before the next withdrawal
            require(periodsSinceLastWithdrawal > 0, "Not yet time to release next batch of tokens");
            require(vestedSaleTokens[uint(saleType)][msg.sender] > 0, "No tokens available in vesting");    

            uint256 totalAmountToBeReleased = userSale.monthlyRelease * periodsSinceLaunch;
            uint256 amount = totalAmountToBeReleased - (totalAmountToBeReleased - userSale.vestedTokens);

            require(amount <= userSale.vestedTokens, "Not enough vested tokens available");
            userSale.vestedTokens -= amount;                                // Update the user's vested tokens post vesting release
            vestedSaleTokens[uint(saleType)][msg.sender] -= amount;     // Update the remaining balances of user's sale tokens post vesting release
            totalVestedBalances[uint(saleType)][address(this)] -= amount; // Update the remaining balances in contract for sale tokens post vesting release
            totalVested -= amount;
            _updateCirculatingSupply();
            totalAmount += amount;                                      // Update total tokens (all 3 sale) to be released from vesting
        }

        require(totalAmount > 0, "No tokens to withdraw");
        _transfer(address(this), msg.sender, totalAmount); // Transfer the total tokens from the contract to the user
        lastWithdrawal[msg.sender] = block.timestamp;
        emit TokensWithdrawn(msg.sender, totalAmount);
    }

    function withdrawOtherVestedTokens() public onlyOwner nonReentrant {
        uint256 totalAmount = 0;
        uint256[] memory distributionAmounts = new uint256[](5);
        uint256 periodsSinceLaunch = (block.timestamp - launchTime) / TOKENS_RELEASE;                                                           // No. of months since the contract launch time
        umonthstamp = periodsSinceLaunch;
        uint256 periodsSinceLastWithdrawal = (block.timestamp - lastWithdrawal[address(this)]) / TOKENS_RELEASE;                                // No. of months since the last withdrawal
        ulsw = periodsSinceLastWithdrawal;
        uint256 maxPeriodsLeft = (MONTHS_IN_4_YEARS >= periodsSinceLaunch ? (MONTHS_IN_4_YEARS - periodsSinceLaunch + 1) : 0);                  // No. of months pending for vested token release
        maxPeriodsLeft = umaxp;
        uint256 periodsToDistribute = periodsSinceLastWithdrawal <= maxPeriodsLeft ? periodsSinceLastWithdrawal : maxPeriodsLeft;               // Determine the number of periods to distribute in this transaction
        udistribute = periodsToDistribute;
        require(periodsToDistribute > 0, "Time since last withdrawal is less than 30 days");   // Ensure the user waits for at least one period before the next withdrawal
        
        for (uint i = 0; i < 5; i++) {
            if (i == 0) {
                distributionAmounts[i] = (VESTING_PERCENTAGE * ((MAX_SUPPLY * volatileControlPercentage) / 100) / 100) / MONTHS_IN_4_YEARS;     //volatileControlMonthlyRelease;
            } else if (i == 1) {
                distributionAmounts[i] = (VESTING_PERCENTAGE * ((MAX_SUPPLY * exchangeListingPercentage) / 100) / 100) / MONTHS_IN_4_YEARS;     //exchangeListingMonthlyRelease;
            } else if (i == 2) {
                distributionAmounts[i] = (VESTING_PERCENTAGE * ((MAX_SUPPLY * ecosystemDevelopmentPercentage) / 100) / 100) / MONTHS_IN_4_YEARS;//ecosystemDevelopmentMonthlyRelease;
            } else if (i == 3) {
                distributionAmounts[i] = (VESTING_PERCENTAGE * ((MAX_SUPPLY * teamPercentage) / 100) / 100) / MONTHS_IN_4_YEARS;                //teamMonthlyRelease;
            } else if (i == 4) {
                distributionAmounts[i] = (VESTING_PERCENTAGE * ((MAX_SUPPLY * reservesPercentage) / 100) / 100) / MONTHS_IN_4_YEARS;            //reserveMonthlyRelease;
            }

            uint256 amount = distributionAmounts[i] * periodsToDistribute;
            totalAmount += amount;
            uamt = totalAmount;

            // Ensure there are enough tokens in the contract for the distribution
            require(balanceOf(address(this)) >= amount, "Not enough tokens in the contract");

            // Transfer the tokens directly to the respective address in fundAllocationAddressesArray
            _transfer(address(this), fundAllocationAddressesArray[i], amount);
        }
        
        // Ensure there are enough vested tokens for the distribution
        require(totalAmount <= totalVested, "Not enough vested tokens available");

        // Update the total vested tokens and circulating supply
        totalVested -= totalAmount;
        _updateCirculatingSupply();

        lastWithdrawal[address(this)] = block.timestamp;
        ulwds = lastWithdrawal[address(this)];
        emit TokensWithdrawn(address(this), totalAmount);
    }

    function viewPendingVestedTokens(address user) public view returns (uint256 Tokens_Vested) {
        uint256 totalPending = 0;  // Initialize the total pending tokens to 0
        uint256 periodsSinceLaunch = (block.timestamp - launchTime) / TOKENS_RELEASE;

        // Calculate the vested tokens for each sale (Seed, Private, Public)
        for (uint i = 0; i < 3; i++) {
            SaleType saleType = SaleType(i);
            SaleData storage userSale = saleData[uint(saleType)][user];

            // Calculate the number of periods since the user's last withdrawal.
            uint256 periodsSinceLastWithdrawal = (block.timestamp - lastWithdrawal[user]) / TOKENS_RELEASE;

            // Skip to the next iteration if no period has passed since the user's last withdrawal or if there are no vested tokens for this sale type.
            if (periodsSinceLastWithdrawal == 0 || userSale.vestedTokens == 0) continue;
                uint256 totalAmountToBeReleased = userSale.monthlyRelease * periodsSinceLaunch;
                uint256 amount = totalAmountToBeReleased - (totalAmountToBeReleased - userSale.vestedTokens);

                // Uses the min helper function below to get the lesser of the two values
                totalPending += min(amount, userSale.vestedTokens);
            }
        return totalPending;
    }

    // Helper function to get the minimum of two values
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
    
    function getSaleBalances() public view returns (uint256 SeedSold, uint256 PrivateSold, uint256 PublicSold) {
        return (
            totalTokensSold[SaleType.Seed],
            totalTokensSold[SaleType.Private],
            totalTokensSold[SaleType.Public]
        );
    }

    function getOtherAllocationTypeAddress() public view returns (address VolatileControl, address ExchangeListing, address EcosystemDevelopment, address Team, address Reserve) {
        return (
            fundAllocationAddressesArray[uint(AllocationType.VolatileControl)], 
            fundAllocationAddressesArray[uint(AllocationType.ExchangeListing)], 
            fundAllocationAddressesArray[uint(AllocationType.EcosystemDevelopment)], 
            fundAllocationAddressesArray[uint(AllocationType.Team)], 
            fundAllocationAddressesArray[uint(AllocationType.Reserve)]);
    }

    function getOtherAllocationTypeBalances() public view returns (uint256 VolatileControl, uint256 ExchangeListing, uint256 EcosystemDevelopment, uint256 Team, uint256 Reserve) {
        return (
            balanceOf(fundAllocationAddressesArray[uint(AllocationType.VolatileControl)]), 
            balanceOf(fundAllocationAddressesArray[uint(AllocationType.ExchangeListing)]), 
            balanceOf(fundAllocationAddressesArray[uint(AllocationType.EcosystemDevelopment)]), 
            balanceOf(fundAllocationAddressesArray[uint(AllocationType.Team)]), 
            balanceOf(fundAllocationAddressesArray[uint(AllocationType.Reserve)]));
    }

    function getCirculatingSupply() public view returns (uint256) {
        return circulatingSupply;
    }
    
    function getTotalSupply() public view returns (uint256) {
        return totalSupply();
    }
    
    function getTotalBurns() public view returns (uint256) {
        return totalBurn;
    }
    
}
